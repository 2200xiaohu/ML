# 对抗验证

作用：识别数据集中更容易造成训练集和测试集之间泄漏的特征。

但是用在哪里？结果怎么用？

```
def get_adv_feats(df_train, df_test, feats):
    df_train['adv'] = 1
    df_test['adv'] = 0
    df = pd.concat([df_train, df_test]).reset_index(drop=True)
    params = {
        'learning_rate': 0.1,
        'boosting_type': 'gbdt',
        'objective': 'binary',
        'metric': 'auc',
        'seed': 2222,
        'n_jobs': 4,
        'verbose': -1,
    }

    fold_num = 5
    seeds = [2222]
    new_feats = []
    for f in feats:
        oof = np.zeros(len(df))
        for seed in seeds:
            kf = StratifiedKFold(n_splits=fold_num, shuffle=True, random_state=seed)
            for fold, (train_idx, val_idx) in enumerate(kf.split(df[[f]], df['adv'])):
                train = lgb.Dataset(df.loc[train_idx, [f]],
                                    df.loc[train_idx, 'adv'])
                val = lgb.Dataset(df.loc[val_idx, [f]],
                                  df.loc[val_idx, 'adv'])
                model = lgb.train(params, train, valid_sets=[val], num_boost_round=10000,  # feval=recall_score,
                                  callbacks=[lgb.early_stopping(100), lgb.log_evaluation(-1)])
                oof[val_idx] += model.predict(df.loc[val_idx, [f]]) / len(seeds)
                score = auc(df.loc[val_idx, 'adv'], oof[val_idx])
                if score > 0.85:
                    print('--------------------------------------', f, score)
                else:
                    new_feats.append(f)
                break
    return new_feats


feats = get_adv_feats(df_train, df_test, feats)
```



feats : 包含特征名字的列表

